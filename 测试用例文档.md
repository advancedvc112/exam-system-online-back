# 接口测试用例文档

## 1. 考试创建接口

**接口路径**: `POST /api/exams/create`  
**请求体**: `ExamCreateRequest`

### 测试用例

#### TC-001: 正常创建考试
- **前置条件**: 存在有效的创建者用户（creatorId）
- **测试数据**:
  ```json
  {
    "examName": "Java基础考试",
    "examDescription": "测试Java基础知识",
    "examType": 1,
    "status": 1,
    "startTime": "2024-12-20 10:00:00",
    "endTime": "2024-12-20 12:00:00",
    "duration": 120,
    "creatorId": 1
  }
  ```
- **预期结果**: 
  - HTTP状态码: 200
  - 返回ExamResponse对象，包含考试ID和基本信息
  - 数据库中创建考试记录，totalScore=0, questionCount=0

#### TC-002: 考试名称为空
- **测试数据**:
  ```json
  {
    "examName": "",
    "examType": 1,
    "status": 1,
    "startTime": "2024-12-20 10:00:00",
    "endTime": "2024-12-20 12:00:00",
    "duration": 120,
    "creatorId": 1
  }
  ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "考试名称不能为空"

#### TC-003: 考试类型为空
- **测试数据**:
  ```json
  {
    "examName": "测试考试",
    "examType": null,
    "status": 1,
    "startTime": "2024-12-20 10:00:00",
    "endTime": "2024-12-20 12:00:00",
    "duration": 120,
    "creatorId": 1
  }
  ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "考试类型不能为空"

#### TC-004: 开始时间早于当前时间
- **测试数据**:
  ```json
  {
    "examName": "测试考试",
    "examType": 1,
    "status": 1,
    "startTime": "2020-01-01 10:00:00",
    "endTime": "2024-12-20 12:00:00",
    "duration": 120,
    "creatorId": 1
  }
  ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "开始时间不能早于当前时间"

#### TC-005: 结束时间早于或等于开始时间
- **测试数据**:
  ```json
  {
    "examName": "测试考试",
    "examType": 1,
    "status": 1,
    "startTime": "2024-12-20 12:00:00",
    "endTime": "2024-12-20 10:00:00",
    "duration": 120,
    "creatorId": 1
  }
  ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "结束时间必须晚于开始时间"

#### TC-006: 考试时长为0或负数
- **测试数据**:
  ```json
  {
    "examName": "测试考试",
    "examType": 1,
    "status": 1,
    "startTime": "2024-12-20 10:00:00",
    "endTime": "2024-12-20 12:00:00",
    "duration": 0,
    "creatorId": 1
  }
  ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "考试时长必须大于0"

#### TC-007: 创建者ID为空
- **测试数据**:
  ```json
  {
    "examName": "测试考试",
    "examType": 1,
    "status": 1,
    "startTime": "2024-12-20 10:00:00",
    "endTime": "2024-12-20 12:00:00",
    "duration": 120,
    "creatorId": null
  }
  ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "创建者不能为空"

---

## 2. 考试进入接口

**接口路径**: `POST /api/student/exams/{examId}/enter`  
**请求体**: `ExamEnterRequest`

### 测试用例

#### TC-101: 正常进入考试
- **前置条件**: 
  - 存在有效的考试（examId），状态为进行中
  - 存在有效的学生用户（studentId，userRole=1）
  - 当前时间在考试开始时间和结束时间之间
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200
  - 返回ExamEnterResponse，包含accessToken、message和participantId
  - Redis中存储token，key为exam:token:{examId}:{studentId}
  - 数据库中创建或更新ExamParticipant记录，status=1（进行中）

#### TC-102: 学生ID为空
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": null
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "学生ID不能为空"

#### TC-103: 用户不存在
- **前置条件**: 不存在studentId对应的用户
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 99999
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "用户不存在"

#### TC-104: 非学生角色进入考试
- **前置条件**: 存在用户但userRole不等于1（如教师或管理员）
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 2
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "只有学生可以进入考试"

#### TC-105: 考试不存在
- **前置条件**: examId对应的考试不存在
- **测试数据**:
  - examId: 99999
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "考试不存在或已被删除"

#### TC-106: 考试尚未开始
- **前置条件**: 考试存在，但当前时间早于startTime
- **测试数据**:
  - examId: 1（startTime为未来时间）
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "考试尚未开始"

#### TC-107: 考试已结束
- **前置条件**: 考试存在，但当前时间晚于endTime
- **测试数据**:
  - examId: 1（endTime为过去时间）
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "考试已结束"

#### TC-108: 重复进入考试
- **前置条件**: 
  - 学生已成功进入考试，Redis中存在token
  - 考试仍在进行中
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "您已进入考试，不允许重复进入"

#### TC-109: 已存在参与记录，重新进入
- **前置条件**: 
  - 数据库中已存在该学生的参与记录（但Redis中token已过期）
  - 考试仍在进行中
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200
  - 更新现有参与记录，生成新token
  - status更新为1（进行中）

---

## 3. 考试退出接口（提交考试）

**接口路径**: `POST /api/student/exams/{examId}/submit`  
**请求体**: `SubmitExamRequest`

### 测试用例

#### TC-201: 正常提交考试
- **前置条件**: 
  - 学生已进入考试（存在参与记录，status=1）
  - 存在缓冲的答题记录
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200
  - 返回: "考试提交成功"
  - 所有缓冲的答题记录被刷新到Redis和MQ
  - 参与记录status更新为2（已提交）
  - submitTime被设置

#### TC-202: 学生ID为空
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": null
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "学生ID不能为空"

#### TC-203: 未找到参与记录
- **前置条件**: 学生未进入考试，不存在参与记录
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "未找到考试参与记录"

#### TC-204: 重复提交（幂等性测试）
- **前置条件**: 参与记录status=2（已提交）
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200
  - 返回: "考试提交成功"
  - 不抛出异常，幂等处理

#### TC-205: 提交时无缓冲答题记录
- **前置条件**: 
  - 学生已进入考试
  - 没有缓冲的答题记录
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200
  - 返回: "考试提交成功"
  - 参与记录status更新为2

#### TC-206: 提交时有多条缓冲答题记录
- **前置条件**: 
  - 学生已进入考试
  - 存在多条缓冲的答题记录（不同sortOrder）
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200
  - 返回: "考试提交成功"
  - 所有缓冲的答题记录都被刷新
  - 参与记录status更新为2

---

## 4. 保存答题接口

**接口路径**: `POST /api/student/exams/{examId}/answers`  
**请求体**: `SaveAnswerRequest`

### 测试用例

#### TC-301: 正常保存答题记录
- **前置条件**: 
  - 学生已进入考试
  - 考试中存在对应sortOrder的题目
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100,
      "sortOrder": 1,
      "answer": "A"
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200
  - 返回: "答题记录已保存"
  - 答题记录被缓冲，3秒后自动写入Redis和MQ
  - Redis中key为answer:{examId}:{studentId}:{sortOrder}

#### TC-302: 学生ID为空
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": null,
      "sortOrder": 1,
      "answer": "A"
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "学生ID不能为空"

#### TC-303: 题目序号为空
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100,
      "sortOrder": null,
      "answer": "A"
    }
    ```
- **预期结果**: 
  - HTTP状态码: 400
  - 错误信息: "题目序号不能为空"

#### TC-304: 保存空答案
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100,
      "sortOrder": 1,
      "answer": ""
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200
  - 返回: "答题记录已保存"
  - 空答案也被保存（允许清空答案）

#### TC-305: 保存长文本答案
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100,
      "sortOrder": 2,
      "answer": "这是一道主观题的答案，内容可能很长，包含多个段落和详细说明..."
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200
  - 返回: "答题记录已保存"
  - 长文本答案被正确保存

#### TC-306: 连续保存同一题目的答案（覆盖测试）
- **前置条件**: 学生已保存过sortOrder=1的答案
- **测试步骤**:
  1. 第一次保存: `{"studentId": 100, "sortOrder": 1, "answer": "A"}`
  2. 等待1秒
  3. 第二次保存: `{"studentId": 100, "sortOrder": 1, "answer": "B"}`
- **预期结果**: 
  - 两次请求都返回200
  - 最终保存的答案应该是"B"（后一次覆盖前一次）
  - 3秒缓冲期内只触发一次写入Redis和MQ

#### TC-307: 保存多个不同题目的答案
- **测试步骤**:
  1. 保存第1题: `{"studentId": 100, "sortOrder": 1, "answer": "A"}`
  2. 保存第2题: `{"studentId": 100, "sortOrder": 2, "answer": "B"}`
  3. 保存第3题: `{"studentId": 100, "sortOrder": 3, "answer": "C"}`
- **预期结果**: 
  - 所有请求都返回200
  - 每个题目的答案都被独立缓冲
  - 3秒后每个答案都写入Redis和MQ

#### TC-308: 保存不存在的题目序号
- **前置条件**: 考试中不存在sortOrder=999的题目
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100,
      "sortOrder": 999,
      "answer": "A"
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200（接口层面成功）
  - 返回: "答题记录已保存"
  - 3秒后写入Redis，但MQ消息中questionId可能为null或记录警告日志

#### TC-309: 保存特殊字符答案
- **测试数据**:
  - examId: 1
  - 请求体:
    ```json
    {
      "studentId": 100,
      "sortOrder": 1,
      "answer": "答案包含特殊字符：<script>alert('xss')</script> & \"引号\""
    }
    ```
- **预期结果**: 
  - HTTP状态码: 200
  - 返回: "答题记录已保存"
  - 特殊字符被正确转义或保存

#### TC-310: 快速连续保存（缓冲机制测试）
- **测试步骤**: 在1秒内连续保存5次同一题目
- **测试数据**:
  ```json
  {
    "studentId": 100,
    "sortOrder": 1,
    "answer": "A"
  }
  ```
- **预期结果**: 
  - 所有请求都返回200
  - 只触发一次写入Redis和MQ（缓冲机制生效）
  - 最终保存的答案是最新一次的值

---

## 测试数据准备说明

### 基础数据
1. **用户数据**:
   - 学生用户: ID=100, userRole=1, isDeleted=0
   - 教师用户: ID=2, userRole=2, isDeleted=0
   - 管理员用户: ID=3, userRole=3, isDeleted=0

2. **考试数据**:
   - 进行中的考试: ID=1, startTime=当前时间-1小时, endTime=当前时间+1小时, status=2
   - 未开始的考试: ID=2, startTime=当前时间+1小时, endTime=当前时间+3小时, status=1
   - 已结束的考试: ID=3, startTime=当前时间-3小时, endTime=当前时间-1小时, status=3

3. **题目数据**:
   - 考试ID=1包含题目: sortOrder=1,2,3对应的questionId

### 环境要求
- Redis服务正常运行
- RocketMQ服务正常运行
- 数据库连接正常
- 系统时间准确

---

## 测试执行建议

1. **执行顺序**: 按照接口依赖关系执行
   - 先执行考试创建接口测试
   - 再执行考试进入接口测试
   - 然后执行保存答题接口测试
   - 最后执行考试退出接口测试

2. **数据清理**: 每个测试用例执行后清理测试数据，避免相互影响

3. **并发测试**: 对于保存答题接口，建议增加并发保存的测试用例

4. **性能测试**: 对于缓冲机制，验证3秒缓冲期的准确性

